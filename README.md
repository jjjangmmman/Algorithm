# 🖥️ Algorithm

|빅오 표기법|코딩테스트 통과 기준(n의 근사값)|
|------|---|
|O(1)|모든 N|
|O(logn)|모든 N|
|O(√n)|모든 N|
|O(n)|모든 N|
|O(nlogn)|10,000,000|
|O(n²)|10,000|
|O(n³)|500|
|O(2ⁿ)|25|
|O(n!)|11|

## 파이썬 Error 모음집
### 구문 오류(SyntaxError)
- += 연산자와 삼항 연산자를 함께 사용하는 것과 같이 복잡한 표현식을 한 줄에 쓰는 것은 허용되지 않습니다.
- 
## 자료 구조 (자주사용하는 메서드, 알고리즘 메모)

### 배열
- 배열 A,B의 원소를 함께 탐색할때 = for x,y in __zip(A,B)__
- \* 연산자: 리스트나 튜플의 요소를 개별 인자로 unpacking
  - ex)print(*iterable): iterable의 각 요소를 개별 인자로 출력
### 문자열
- 문자열 슬라이싱 [start:stop(end+1):step(default=1)]
- 역순 슬라이싱 [::-1]
- islower(),isupper() = __'bool'__ 반환 / lower(),upper() = 치환한 __'문자열'__ 반환
- 기본형: str.replace(old, new[, count]) __특정 횟수만큼 대체__ / text = text.replace("one", "1").replace("two", "2").replace("three", "3") 이런식으로 __다중 대체__ 도 가능
- 기본형: str.split(sep=None, maxsplit=-1) 부분 문자열을 요소로하는 __리스트 반환__
  - sep = 구분자 ex)text.split(',') 생략시 공백을 구분자
  - maxsplit = 나눌 횟수의 최대값. ex)text.split(' ', 2) 두번까지만 나누고 나머지는 하나의 요소로 처리해서 리스트 반환 생략시 -1이 기본값으로 횟수제한없이 나눔
- def parse_@@@ = 입력 리스트의 요소 처리 함수를 따로 정의하고 solution함수에서
  for _ in map(parse_@@@, 입력리스트) 이런식으로 map을 사용하면 가독성도 좋고 유지보수도 좋아질 수 있다!
### 딕셔너리
- 대응관계를 표현할 때 사용
- 리스트처럼 순차적으로 요솟값에 접근하지않음 = 인덱스를 통한 접근이아니라는 뜻
- 딕셔너리는 키를 통해 값을 얻는다! [index]=❌, [key]=⭕
- 따라서 순차적으로 탐색해서 값을 얻지않으므로 O(n)이아니고 O(1)
- 키값은 불변 객체 (숫자형, 문자형, 튜플)
- 불변 객체는 값이 동일하면 같은 객체를 가르키므로 딕셔너리 __키값은 중복될 수 없음__ (id()로 객체의 식별자 확인가능)
- +@ = 동일한 키를 추가하면 기존의 키와 값이 나중에 추가된것으로 변경됨
- value에대한 비교가 필요하지않고 key의 중복여부만 필요할때는 집합 컴프리헨션을 사용하면 더 간단하고 효율적✨
### 큐

