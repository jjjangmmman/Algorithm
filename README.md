# 🖥️ Algorithm

|빅오 표기법|코딩테스트 통과 기준(n의 근사값)|
|------|---|
|O(1)|모든 N|
|O(logn)|모든 N|
|O(√n)|모든 N|
|O(n)|모든 N|
|O(nlogn)|10,000,000|
|O(n²)|10,000|
|O(n³)|500|
|O(2ⁿ)|25|
|O(n!)|11|

<알고리즘 설계>
1. 사용된 알고리즘이 정확한가? (=문제를 해결할 수 있는가?)
2. 사용된 알고리즘이 효율적으로 동작하는가? (시간복잡도)
   
## 파이썬 Error 모음집
### 구문 오류(SyntaxError)
- += 연산자와 삼항 연산자를 함께 사용하는 것과 같이 복잡한 표현식을 한 줄에 쓰는 것은 허용되지 않습니다.
- 
## 자료 구조 (자주사용하는 메서드, 알고리즘 메모)

### 배열
- 배열 A,B의 원소를 함께 탐색할때 = for x,y in __zip(A,B)__
- \* 연산자: 리스트나 튜플의 요소를 개별 인자로 unpacking
  - ex)print(*iterable): iterable의 각 요소를 개별 인자로 출력
### 문자열
- 문자열 슬라이싱 [start:stop(end+1):step(default=1)]
- 역순 슬라이싱 [::-1]
- islower(),isupper() = __'bool'__ 반환 / lower(),upper() = 치환한 __'문자열'__ 반환
- 기본형: str.replace(old, new[, count]) __특정 횟수만큼 대체__ / text = text.replace("one", "1").replace("two", "2").replace("three", "3") 이런식으로 __다중 대체__ 도 가능
- 기본형: str.split(sep=None, maxsplit=-1) 부분 문자열을 요소로하는 __리스트 반환__
  - sep = 구분자 ex)text.split(',') 생략시 공백을 구분자
  - maxsplit = 나눌 횟수의 최대값. ex)text.split(' ', 2) 두번까지만 나누고 나머지는 하나의 요소로 처리해서 리스트 반환 생략시 -1이 기본값으로 횟수제한없이 나눔
- def parse_@@@ = 입력 리스트의 요소 처리 함수를 따로 정의하고 solution함수에서
  for _ in map(parse_@@@, 입력리스트) 이런식으로 map을 사용하면 가독성도 좋고 유지보수도 좋아질 수 있다!
### 딕셔너리
- 대응관계를 표현할 때 사용
- 리스트처럼 순차적으로 요솟값에 접근하지않음 = 인덱스를 통한 접근이아니라는 뜻
- 딕셔너리는 키를 통해 값을 얻는다! [index]=❌, [key]=⭕
- 따라서 순차적으로 탐색해서 값을 얻지않으므로 O(n)이아니고 O(1)
- 키값은 불변 객체 (숫자형, 문자형, 튜플)
- 불변 객체는 값이 동일하면 같은 객체를 가르키므로 딕셔너리 __키값은 중복될 수 없음__ (id()로 객체의 식별자 확인가능)
- +@ = 동일한 키를 추가하면 기존의 키와 값이 나중에 추가된것으로 변경됨
- value에대한 비교가 필요하지않고 key의 중복여부만 필요할때는 집합 컴프리헨션을 사용하면 더 간단하고 효율적✨
### 큐
- from collections import deque 사용
- enqueue() = 덱의 append() / dequeue() = 덱의 popleft() 사용
- 덱의 rotate(_n=1_)메서드 = 원형큐의 느낌 구현가능
    -  덱을 n 단계 오른쪽,시계방향 회전 (n이 음수면 왼쪽 회전)
    -  큐에서 사용할 경우 append와 popleft를 쓰니까 음수로 rotate를 쓰고 __"왼쪽으로 한 단계 회전하는 것은 d.append(d.popleft())와 동등"__

## 완전 탐색 
(무식하게 가능한 모든 경우를 탐색한다는 의미 "_Brute Force,브루트포스 알고리즘_")
완전탐색은 직관적이고 이해하기 쉬운 방법이기 때문에 알고리즘의 정확성은 보장이되지만,
입력의 크기가 커지면 시간조건을 만족하지 못할 수 있다. (-> 이럴 때 동적 계획법같은 서은ㅇ 최적화 알고리즘을 사용해야 한다.)따라서

__<완전 탐색 기법>__
1. 해결하고자 하는 문제의 가능한 경우의 수(입력크기)를 대략적으로 계산
2. 반복,재귀를 사용하는 방법 고려
3. 실제로 답을 시간조건을 만족하며 해결할 수 있는지 확인

### from itertools import * (permutations, combinations, product)
1. 1부터 N까지 자연수 중에서 __중복 없이__ M개를 고른 수열
  1. 순서를 고려한 순열 permutations
  2. 순서를 고려하지않는 조합 combinations
3. 1부터 N까지 자연수 중에서 중복 가능하게 M개를 고른 수열 product
만약 재귀로 위의 3가지를 구현하게되면
- __중복 없이__ = 시간복잡도가 __N!__ -> n=10까지 커버가능
  - 중복 여부를 체크하는 bool[] 방문list 필
- __중복 가능__ = 시간복잡도가 __N^N__ -> n=8까지 커버가능

### 재귀함수, 백트래킹

```
def recur(num): #num은 재귀과정을 트리로 표현했을때 depth
    if num==M: #기본 base 조건 : 재귀를 멈추는 조건
        print(*rs)
        return
    for i in range(1,N+1): #재귀 조건 : 각 단계에서 다음으로 재귀호출 할때 처리할 작업
        rs.append(i)
        recur(num+1)
        rs.pop() # 백트래킹 : 재귀 호출이 끝나고 돌아왔을때 상태를 되돌리는 작업
recur(0)
```
